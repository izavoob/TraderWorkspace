{
  "src/App.jsx": "import React from 'react'; import { Routes, Route, useLocation, useNavigate } from 'react-router-dom'; import Home from './components/Home.jsx'; import TradeJournal from './components/TradeJournal.jsx'; import TradeDetail from './components/TradeDetail.jsx'; import Placeholder from './components/Placeholder.jsx'; import CreateTrade from './components/CreateTrade.jsx'; import DailyRoutine from './components/DailyRoutine.jsx'; import PreSessionJournal from './components/PreSessionJournal.jsx'; import PostSessionJournal from './components/PostSessionJournal.jsx'; import LearningSection from './components/LearningSection.jsx'; // Новый импорт import EmotionsControl from './components/EmotionsControl.jsx'; // Новый импорт import Notes from './components/Notes.jsx'; // Новый импорт import styled, { createGlobalStyle } from 'styled-components'; const GlobalStyle = createGlobalStyle` body, html { margin: 0; padding: 0; height: 100%; width: 100%; background-color: #1a1a1a; overflow-x: hidden; } ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: transparent; } ::-webkit-scrollbar-thumb { background: #7425C9; border-radius: 3px; } ::-webkit-scrollbar-thumb:hover { background: #5e2ca5; } `; const AppContainer = styled.div` text-align: center; position: relative; background-color: #1a1a1a; color: #fff; margin: 0; padding: 20px; min-height: 100vh; box-sizing: border-box; width: 100%; overflow-x: hidden; `; const NavigationButtons = styled.div` position: absolute; top: 10px; left: 10px; display: flex; align-items: center; &.hidden { display: none; } `; const NavButton = styled.button` background-color: #5e2ca5; color: #fff; border: none; padding: 6px 10px; margin: 0; border-radius: 4px; cursor: pointer; width: 38px; height: 38px; display: flex; align-items: center; justify-content: center; transition: transform 0.2s ease, background-color 0.2s ease; &.back { border-right: 2px solid #4a1a8d; } &.forward { margin-left: '-2px'; } &:hover { background-color: #4a1a8d; transform: scale(1.1); } &:active { transform: scale(0.95); } &:before { font-size: 20px; } &.back::before { content: \"\\\\2190\"; } &.forward::before { content: \"\\\\2192\"; } `; function App() { const location = useLocation(); const isHome = location.pathname === '/'; const navigate = useNavigate(); const handleBack = () => { navigate(-1); }; const handleForward = () => { navigate(1); }; return ( <> <GlobalStyle /> <AppContainer> {!isHome && <h2 style={{ color: '#5e2ca5' }}>{getSectionTitle(location.pathname)}</h2>} <NavigationButtons className={isHome ? 'hidden' : ''}> <NavButton onClick={handleBack} className=\"back\" aria-label=\"Back\" /> <NavButton onClick={handleForward} className=\"forward\" aria-label=\"Forward\" /> </NavigationButtons> <Routes> <Route path=\"/\" element={<Home />} /> <Route path=\"/trade-journal\" element={<TradeJournal />} /> <Route path=\"/trade/:id\" element={<TradeDetail />} /> <Route path=\"/create-trade\" element={<CreateTrade />} /> <Route path=\"/daily-routine\" element={<DailyRoutine />} /> <Route path=\"/daily-routine/pre-session\" element={<PreSessionJournal />} /> <Route path=\"/daily-routine/post-session\" element={<PostSessionJournal />} /> <Route path=\"/learning-section\" element={<LearningSection />} /> <Route path=\"/learning-section/emotions\" element={<EmotionsControl />} /> <Route path=\"/learning-section/notes\" element={<Notes />} /> <Route path=\"/performance-analysis\" element={<Placeholder title=\"Performance Analysis\" />} /> <Route path=\"/statistics\" element={<Placeholder title=\"Statistics\" />} /> <Route path=\"/risk-management\" element={<Placeholder title=\"Risk Management\" />} /> <Route path=\"/reporting-system\" element={<Placeholder title=\"Reporting System\" />} /> <Route path=\"/settings\" element={<Placeholder title=\"Settings\" />} /> </Routes> </AppContainer> </> ); } function getSectionTitle(path) { switch (path) { case '/daily-routine': return 'DAILY ROUTINE'; case '/daily-routine/pre-session': return 'PRE-SESSION JOURNAL'; case '/daily-routine/post-session': return 'POST-SESSION JOURNAL'; case '/learning-section': return 'LEARNING SECTION'; case '/learning-section/emotions': return 'EMOTIONS & CONTROL'; case '/learning-section/notes': return 'NOTES'; case '/trade-journal': return 'TRADE JOURNAL'; case '/create-trade': return 'CREATE TRADE'; default: return path.split('/')[1]?.toUpperCase() || ''; } } export default App;",
  "src/components/CreateTrade.jsx": "import React, { useState, useEffect } from 'react'; import { useNavigate } from 'react-router-dom'; import styled from 'styled-components'; const CreateTradeContainer = styled.div` max-width: 1820px; margin: 20px auto; min-height: 100vh; background-color: #1a1a1a; padding: 20px; overflow-y: auto; overflow-x: hidden; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425c9, #b886ee); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled.button` background: conic-gradient(from 45deg, #7425c9, #b886ee); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: 'Back'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const TradeNumber = styled.p` color: #fff; font-size: 1.2em; margin: 10px 0; `; const TradeContent = styled.div` margin-top: 148px; padding-top: 20px; display: flex; flex-direction: column; align-items: center; width: 100%; `; const TablesContainer = styled.div` display: flex; gap: 20px; width: 100%; `; const TradeTable = styled.div` flex: 1; background-color: #2e2e2e; padding: 20px; border-radius: 5px; border: 2px solid #5e2ca5; `; const FormRow = styled.div` display: flex; gap: 15px; margin-bottom: 15px; `; const FormField = styled.div` flex: 1; `; const FormLabel = styled.label` color: #fff; margin-bottom: 5px; display: block; `; const FormInput = styled.input` padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; width: 100%; `; const FormSelect = styled.select` padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; width: 100%; `; const FormCheckbox = styled.input` margin-right: 10px; `; const FormButton = styled.button` background: conic-gradient(from 45deg, #7425c9, #b886ee); color: #fff; border: none; padding: 10px 20px; border-radius: 15px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; min-width: 120px; &:hover { transform: scale(1.05); opacity: 0.9; } &:active { transform: scale(0.95); } `; const ButtonGroup = styled.div` display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px; width: 100%; `; const VolumeConfirmationContainer = styled.div` position: relative; `; const VolumeConfirmationButton = styled.button` padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; width: 100%; text-align: left; `; const VolumeConfirmationPopup = styled.div` position: absolute; top: 100%; left: 0; background-color: #3e3e3e; border: 1px solid #5e2ca5; border-radius: 5px; padding: 10px; z-index: 1000; `; const VolumeOption = styled.div` padding: 5px; cursor: pointer; background-color: ${(props) => (props.selected ? 'rgba(0, 0, 255, 0.5)' : 'transparent')}; color: #fff; &:hover { background-color: #5e2ca5; } `; const ConfirmButton = styled.button` margin-top: 10px; background: conic-gradient(from 45deg, #7425c9, #b886ee); color: #fff; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; `; const SectionTitle = styled.h2` color: #5e2ca5; margin: 20px 0 10px; font-size: 2em; `; const ScreenshotContainer = styled.div` display: flex; flex-wrap: wrap; gap: 20px; width: 100%; `; const ScreenshotField = styled.div` flex: 1 1 45%; background-color: #2e2e2e; padding: 15px; border-radius: 5px; border: 2px solid #5e2ca5; position: relative; display: flex; flex-direction: column; align-items: center; &:hover .delete-screenshot { opacity: 1; } `; const ScreenshotTitle = styled.h3` color: #fff; margin-bottom: 10px; font-size: 1em; `; const ScreenshotInput = styled.input` width: 100%; padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; margin-bottom: 10px; text-align: center; `; const ScreenshotPreview = styled.img` width: 100%; height: auto; margin-bottom: 10px; cursor: pointer; `; const TextArea = styled.textarea` width: 100%; padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; min-height: 100px; text-align: center; `; const Row = styled.div` display: flex; gap: 20px; width: 100%; `; const NoteContainer = styled.div` width: 100%; `; const NoteItem = styled.div` background-color: #2e2e2e; padding: 10px; border-radius: 5px; border: 1px solid #5e2ca5; margin-bottom: 10px; cursor: pointer; position: relative; `; const NoteText = styled.p` margin: 0; color: #fff; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; `; const IconButton = styled.button` background: conic-gradient(from 45deg, #7425c9, #b886ee); border: none; cursor: pointer; width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); position: absolute; top: 10px; &:hover { filter: brightness(1.5); } img { width: 16px; height: 16px; } &.edit { right: 40px; } &.delete { right: 10px; } `; const DeleteScreenshotButton = styled.button` background: conic-gradient(from 45deg, #7425c9, #b886ee); border: none; cursor: pointer; width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); position: absolute; top: 10px; right: 10px; opacity: 0; transition: opacity 0.2s ease; &:hover { filter: brightness(1.5); } img { width: 16px; height: 16px; } `; const FullscreenModal = styled.div` position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.9); display: flex; align-items: center; justify-content: center; z-index: 2000; `; const FullscreenImage = styled.img` max-width: 90%; max-height: 90%; `; const CloseButton = styled.button` position: absolute; top: 20px; right: 20px; background: conic-gradient(from 45deg, #7425c9, #b886ee); border: none; padding: 10px; border-radius: 50%; cursor: pointer; color: #fff; font-size: 1.2em; `; const NotePopup = styled.div` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: calc(100vw / 2); height: calc(100vh / 2); background-color: #2e2e2e; padding: 20px; border-radius: 10px; border: 2px solid #5e2ca5; color: #fff; z-index: 1001; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); display: flex; flex-direction: column; gap: 10px; `; const NotePopupTitle = styled.h3` color: #fff; margin: 0 0 10px; `; const NotePopupInput = styled.input` padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; width: 100%; `; const NotePopupTextArea = styled.textarea` padding: 8px; background-color: #3e3e3e; color: #fff; border: 1px solid #5e2ca5; border-radius: 5px; width: 100%; flex-grow: 1; `; const NotePopupButtons = styled.div` display: flex; gap: 10px; justify-content: flex-end; `; function CreateTrade() { const navigate = useNavigate(); const [tradeCount, setTradeCount] = useState(0); const [trade, setTrade] = useState({ date: new Date().toISOString().split('T')[0], account: '', pair: '', direction: '', positionType: '', risk: '', result: '', rr: '', profitLoss: '', gainedPoints: '', followingPlan: false, bestTrade: false, session: '', pointA: '', trigger: '', volumeConfirmation: [], entryModel: '', entryTF: '', fta: '', slPosition: '', score: '', category: '', topDownAnalysis: [ { title: 'Daily Timeframe', screenshot: '', text: '' }, { title: '4h Timeframe', screenshot: '', text: '' }, { title: '1h Timeframe', screenshot: '', text: '' }, { title: '15/5m Timeframe', screenshot: '', text: '' }, ], execution: { screenshot: '', text: '' }, management: { screenshot: '', text: '' }, conclusion: { videoLink: '', text: '' }, notes: [], }); const [showVolumePopup, setShowVolumePopup] = useState(false); const [tempVolumeConfirmation, setTempVolumeConfirmation] = useState([]); const [showNotePopup, setShowNotePopup] = useState(false); const [noteTitle, setNoteTitle] = useState(''); const [noteText, setNoteText] = useState(''); const [editNoteIndex, setEditNoteIndex] = useState(null); const [fullscreenImage, setFullscreenImage] = useState(null); useEffect(() => { window.electronAPI.getTrades().then((trades) => { setTradeCount(trades.length + 1); }).catch((error) => { console.error('Error fetching trade count:', error); setTradeCount(1); }); }, []); const handleChange = (e) => { const { name, value, type, checked } = e.target; setTrade((prev) => { const newTrade = { ...prev, [name]: type === 'checkbox' ? checked : value }; if (name === 'rr' || name === 'risk' || name === 'result') { const risk = parseFloat(newTrade.risk) || 0; const rr = parseFloat(newTrade.rr) || 0; newTrade.profitLoss = newTrade.result === 'Win' ? risk * rr : newTrade.result === 'Loss' ? -risk : ''; newTrade.gainedPoints = 'Coming soon'; } return newTrade; }); }; const handleVolumeOptionClick = (option) => { setTempVolumeConfirmation((prev) => prev.includes(option) ? prev.filter((item) => item !== option) : [...prev, option] ); }; const handleVolumeConfirm = () => { setTrade((prev) => ({ ...prev, volumeConfirmation: tempVolumeConfirmation })); setShowVolumePopup(false); }; const handleScreenshotChange = (section, index, field, value) => { setTrade((prev) => { if (section === 'topDownAnalysis') { const updated = [...prev.topDownAnalysis]; updated[index] = { ...updated[index], [field]: value }; return { ...prev, topDownAnalysis: updated }; } else { return { ...prev, [section]: { ...prev[section], [field]: value } }; } }); }; const handlePaste = async (section, index, e) => { const items = e.clipboardData.items; for (let item of items) { if (item.type.startsWith('image/')) { const blob = item.getAsFile(); try { const buffer = await blob.arrayBuffer(); const filePath = await window.electronAPI.saveBlobAsFile(buffer); handleScreenshotChange(section, index, 'screenshot', filePath); } catch (error) { console.error('Error saving blob as file:', error); alert('Failed to save screenshot.'); } e.preventDefault(); return; } } }; const deleteScreenshot = (section, index) => { setTrade((prev) => { if (section === 'topDownAnalysis') { const updated = [...prev.topDownAnalysis]; updated[index] = { ...updated[index], screenshot: '' }; return { ...prev, topDownAnalysis: updated }; } else { return { ...prev, [section]: { ...prev[section], screenshot: '' } }; } }); }; const openFullscreen = (src) => { setFullscreenImage(src); }; const closeFullscreen = () => { setFullscreenImage(null); }; const openNotePopup = (index = null) => { if (index !== null) { setNoteTitle(trade.notes[index].title); setNoteText(trade.notes[index].text); setEditNoteIndex(index); } else { setNoteTitle(''); setNoteText(''); setEditNoteIndex(null); } setShowNotePopup(true); }; const saveNote = () => { if (noteTitle && noteText) { const note = { title: noteTitle, text: noteText }; setTrade((prev) => { if (editNoteIndex !== null) { const updatedNotes = [...prev.notes]; updatedNotes[editNoteIndex] = note; return { ...prev, notes: updatedNotes }; } else { return { ...prev, notes: [...prev.notes, note] }; } }); setShowNotePopup(false); setNoteTitle(''); setNoteText(''); setEditNoteIndex(null); } }; const deleteNote = (index) => { setTrade((prev) => ({ ...prev, notes: prev.notes.filter((_, i) => i !== index), })); setShowNotePopup(false); }; const cancelNote = () => { setShowNotePopup(false); setNoteTitle(''); setNoteText(''); setEditNoteIndex(null); }; const handleSubmit = async (e) => { e.preventDefault(); try { const tradeData = { id: Date.now().toString(), ...trade, risk: trade.risk ? `${trade.risk}%` : '', rr: trade.rr ? `${trade.rr}RR` : '', volumeConfirmation: trade.volumeConfirmation.join(', '), }; await window.electronAPI.saveTrade(tradeData); navigate('/trade-journal'); } catch (error) { console.error('Error saving trade:', error); alert('Failed to save trade. Please try again.'); } }; const handleBack = () => { navigate('/trade-journal', { replace: true }); }; return ( <CreateTradeContainer> <Header> <BackButton onClick={handleBack} /> <Title>New Trade</Title> </Header> <TradeContent> <TradeNumber>Trade number: {tradeCount}</TradeNumber> <TablesContainer> <TradeTable> <FormRow> <FormField> <FormLabel>Date</FormLabel> <FormInput type=\"date\" name=\"date\" value={trade.date} onChange={handleChange} /> </FormField> <FormField> <FormLabel>Account</FormLabel> <FormSelect name=\"account\" value={trade.account} onChange={handleChange} disabled> <option value=\"\">Coming soon</option> </FormSelect> </FormField> <FormField> <FormLabel>Pair</FormLabel> <FormSelect name=\"pair\" value={trade.pair} onChange={handleChange}> <option value=\"\">Select Pair</option> <option value=\"EURUSD\">EURUSD</option> <option value=\"GBPUSD\">GBPUSD</option> <option value=\"USDJPY\">USDJPY</option> <option value=\"GER40\">GER40</option> <option value=\"XAUUSD\">XAUUSD</option> <option value=\"XAGUSD\">XAGUSD</option> </FormSelect> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>Direction</FormLabel> <FormSelect name=\"direction\" value={trade.direction} onChange={handleChange}> <option value=\"\">Select Direction</option> <option value=\"Long\" style={{ backgroundColor: '#00ff00', color: '#000' }}>Long</option> <option value=\"Short\" style={{ backgroundColor: '#ff0000', color: '#fff' }}>Short</option> </FormSelect> </FormField> <FormField> <FormLabel>Position Type</FormLabel> <FormSelect name=\"positionType\" value={trade.positionType} onChange={handleChange}> <option value=\"\">Select Position Type</option> <option value=\"Intraday\">Intraday</option> <option value=\"Swing\">Swing</option> </FormSelect> </FormField> <FormField> <FormLabel>Risk, %</FormLabel> <FormInput type=\"number\" name=\"risk\" value={trade.risk} onChange={handleChange} placeholder=\"Enter risk\" step=\"0.01\" /> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>Result</FormLabel> <FormSelect name=\"result\" value={trade.result} onChange={handleChange}> <option value=\"\">Select Result</option> <option value=\"Win\" style={{ backgroundColor: '#00ff00', color: '#000' }}>Win</option> <option value=\"Loss\" style={{ backgroundColor: '#ff0000', color: '#fff' }}>Loss</option> </FormSelect> </FormField> <FormField> <FormLabel>RR</FormLabel> <FormInput type=\"number\" name=\"rr\" value={trade.rr} onChange={handleChange} placeholder=\"Enter RR\" step=\"0.01\" /> </FormField> <FormField> <FormLabel>Profit (%)</FormLabel> <FormInput type=\"text\" name=\"profitLoss\" value={trade.profitLoss} readOnly /> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>Profit ($)</FormLabel> <FormInput type=\"text\" name=\"gainedPoints\" value={trade.gainedPoints || 'Coming soon'} readOnly /> </FormField> <FormField> <FormLabel> <FormCheckbox type=\"checkbox\" name=\"followingPlan\" checked={trade.followingPlan} onChange={handleChange} /> Following the Plan? </FormLabel> </FormField> <FormField> <FormLabel> <FormCheckbox type=\"checkbox\" name=\"bestTrade\" checked={trade.bestTrade} onChange={handleChange} /> Best Trade? </FormLabel> </FormField> </FormRow> </TradeTable> <TradeTable> <FormRow> <FormField> <FormLabel>Session</FormLabel> <FormSelect name=\"session\" value={trade.session} onChange={handleChange}> <option value=\"\">Select Session</option> <option value=\"Asia\" style={{ backgroundColor: '#0000ff', color: '#fff' }}>Asia</option> <option value=\"Frankfurt\" style={{ backgroundColor: '#ff69b4', color: '#fff' }}>Frankfurt</option> <option value=\"London\" style={{ backgroundColor: '#00ff00', color: '#000' }}>London</option> <option value=\"New York\" style={{ backgroundColor: '#ffa500', color: '#fff' }}>New York</option> </FormSelect> </FormField> <FormField> <FormLabel>Point A</FormLabel> <FormSelect name=\"pointA\" value={trade.pointA} onChange={handleChange}> <option value=\"\">Select Point A</option> <option value=\"Fractal Raid\">Fractal Raid</option> <option value=\"FVG\">FVG</option> <option value=\"SNR\">SNR</option> <option value=\"RB\">RB</option> </FormSelect> </FormField> <FormField> <FormLabel>Trigger</FormLabel> <FormSelect name=\"trigger\" value={trade.trigger} onChange={handleChange}> <option value=\"\">Select Trigger</option> <option value=\"Fractal Swing\">Fractal Swing</option> <option value=\"FVG\">FVG</option> <option value=\"Fractal Swing + FVG\">Fractal Swing + FVG</option> </FormSelect> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>Volume Confirmation</FormLabel> <VolumeConfirmationContainer> <VolumeConfirmationButton onClick={() => setShowVolumePopup(true)}> {trade.volumeConfirmation.length > 0 ? trade.volumeConfirmation.join(', ') : 'Select'} </VolumeConfirmationButton> {showVolumePopup && ( <VolumeConfirmationPopup> {['Inversion', 'FVG', 'SNR'].map((option) => ( <VolumeOption key={option} selected={tempVolumeConfirmation.includes(option)} onClick={() => handleVolumeOptionClick(option)} > {option} </VolumeOption> ))} <ConfirmButton onClick={handleVolumeConfirm}>Confirm</ConfirmButton> </VolumeConfirmationPopup> )} </VolumeConfirmationContainer> </FormField> <FormField> <FormLabel>Entry Model</FormLabel> <FormSelect name=\"entryModel\" value={trade.entryModel} onChange={handleChange}> <option value=\"\">Select Entry Model</option> <option value=\"Inversion\">Inversion</option> <option value=\"Displacement\">Displacement</option> <option value=\"SNR\">SNR</option> <option value=\"IDM\">IDM</option> </FormSelect> </FormField> <FormField> <FormLabel>Entry TF</FormLabel> <FormSelect name=\"entryTF\" value={trade.entryTF} onChange={handleChange}> <option value=\"\">Select Entry TF</option> <option value=\"3m\">3m</option> <option value=\"5m\">5m</option> <option value=\"15m\">15m</option> <option value=\"1h/30m\">1h/30m</option> <option value=\"4h\">4h</option> </FormSelect> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>FTA</FormLabel> <FormSelect name=\"fta\" value={trade.fta} onChange={handleChange}> <option value=\"\">Select FTA</option> <option value=\"Fractal Swing\">Fractal Swing</option> <option value=\"FVG\">FVG</option> <option value=\"SNR\">SNR</option> <option value=\"RB\">RB</option> </FormSelect> </FormField> <FormField> <FormLabel>SL Position</FormLabel> <FormSelect name=\"slPosition\" value={trade.slPosition} onChange={handleChange}> <option value=\"\">Select SL Position</option> <option value=\"LTF/Lunch Manipulation\">LTF/Lunch Manipulation</option> <option value=\"30m Raid\">30m Raid</option> <option value=\"1h Raid\">1h Raid</option> <option value=\"4h Raid\">4h Raid</option> <option value=\"1D Raid\">1D Raid</option> </FormSelect> </FormField> <FormField> <FormLabel>Score</FormLabel> <FormInput type=\"number\" name=\"score\" value={trade.score} onChange={handleChange} placeholder=\"Enter score\" /> </FormField> </FormRow> <FormRow> <FormField> <FormLabel>Category</FormLabel> <FormInput type=\"text\" name=\"category\" value={trade.category || 'Coming soon'} readOnly /> </FormField> </FormRow> </TradeTable> </TablesContainer> <SectionTitle>Top Down Analysis</SectionTitle> <ScreenshotContainer> {trade.topDownAnalysis.map((item, index) => ( <ScreenshotField key={index}> <ScreenshotTitle>{item.title}</ScreenshotTitle> {!item.screenshot && ( <ScreenshotInput type=\"text\" placeholder=\"Paste screenshot here (Ctrl+V)\" onPaste={(e) => handlePaste('topDownAnalysis', index, e)} /> )} {item.screenshot && ( <ScreenshotPreview src={item.screenshot} alt=\"Screenshot\" onClick={() => openFullscreen(item.screenshot)} /> )} <TextArea value={item.text} onChange={(e) => handleScreenshotChange('topDownAnalysis', index, 'text', e.target.value)} /> {item.screenshot && ( <DeleteScreenshotButton className=\"delete-screenshot\" onClick={() => deleteScreenshot('topDownAnalysis', index)}> <img src=\"/assets/delete-icon.svg\" alt=\"Delete\" /> </DeleteScreenshotButton> )} </ScreenshotField> ))} </ScreenshotContainer> <Row> <div style={{ flex: 1 }}> <SectionTitle>Execution</SectionTitle> <ScreenshotField> <ScreenshotTitle>Exit Moment</ScreenshotTitle> {!trade.execution.screenshot && ( <ScreenshotInput type=\"text\" placeholder=\"Paste screenshot here (Ctrl+V)\" onPaste={(e) => handlePaste('execution', 0, e)} /> )} {trade.execution.screenshot && ( <ScreenshotPreview src={trade.execution.screenshot} alt=\"Screenshot\" onClick={() => openFullscreen(trade.execution.screenshot)} /> )} <TextArea value={trade.execution.text} onChange={(e) => handleScreenshotChange('execution', 0, 'text', e.target.value)} /> {trade.execution.screenshot && ( <DeleteScreenshotButton className=\"delete-screenshot\" onClick={() => deleteScreenshot('execution', 0)}> <img src=\"/assets/delete-icon.svg\" alt=\"Delete\" /> </DeleteScreenshotButton> )} </ScreenshotField> </div> <div style={{ flex: 1 }}> <SectionTitle>Management</SectionTitle> <ScreenshotField> <ScreenshotTitle>First Trouble Area</ScreenshotTitle> {!trade.management.screenshot && ( <ScreenshotInput type=\"text\" placeholder=\"Paste screenshot here (Ctrl+V)\" onPaste={(e) => handlePaste('management', 0, e)} /> )} {trade.management.screenshot && ( <ScreenshotPreview src={trade.management.screenshot} alt=\"Screenshot\" onClick={() => openFullscreen(trade.management.screenshot)} /> )} <TextArea value={trade.management.text} onChange={(e) => handleScreenshotChange('management', 0, 'text', e.target.value)} /> {trade.management.screenshot && ( <DeleteScreenshotButton className=\"delete-screenshot\" onClick={() => deleteScreenshot('management', 0)}> <img src=\"/assets/delete-icon.svg\" alt=\"Delete\" /> </DeleteScreenshotButton> )} </ScreenshotField> </div> </Row> <Row> <div style={{ flex: 1 }}> <SectionTitle>Conclusion</SectionTitle> <ScreenshotField> <ScreenshotTitle>Daily Performance Analysis</ScreenshotTitle> <ScreenshotInput type=\"text\" placeholder=\"YouTube video link\" value={trade.conclusion.videoLink} onChange={(e) => handleScreenshotChange('conclusion', 0, 'videoLink', e.target.value)} /> <TextArea value={trade.conclusion.text} onChange={(e) => handleScreenshotChange('conclusion', 0, 'text', e.target.value)} /> </ScreenshotField> </div> <div style={{ flex: 1 }}> <SectionTitle>Notes & Mistakes</SectionTitle> <NoteContainer> {trade.notes.map((note, index) => ( <NoteItem key={index} onClick={() => openNotePopup(index)}> <NoteText>{note.title}</NoteText> <IconButton className=\"edit\" onClick={(e) => { e.stopPropagation(); openNotePopup(index); }}> <img src=\"/assets/edit-icon.svg\" alt=\"Edit\" /> </IconButton> <IconButton className=\"delete\" onClick={(e) => { e.stopPropagation(); deleteNote(index); }}> <img src=\"/assets/delete-icon.svg\" alt=\"Delete\" /> </IconButton> </NoteItem> ))} <FormButton onClick={() => openNotePopup()}>Add Note or Mistake</FormButton> </NoteContainer> </div> </Row> {showNotePopup && ( <NotePopup> <NotePopupTitle>Adding Notes & Mistakes</NotePopupTitle> <NotePopupInput type=\"text\" placeholder=\"Enter note title\" value={noteTitle} onChange={(e) => setNoteTitle(e.target.value)} /> <NotePopupTextArea placeholder=\"Enter note text\" value={noteText} onChange={(e) => setNoteText(e.target.value)} /> <NotePopupButtons> <FormButton onClick={saveNote}>Save</FormButton> <FormButton onClick={cancelNote}>Cancel</FormButton> {editNoteIndex !== null && ( <FormButton onClick={() => deleteNote(editNoteIndex)}>Delete</FormButton> )} </NotePopupButtons> </NotePopup> )} {fullscreenImage && ( <FullscreenModal onClick={closeFullscreen}> <FullscreenImage src={fullscreenImage} alt=\"Fullscreen Screenshot\" /> <CloseButton>X</CloseButton> </FullscreenModal> )} <ButtonGroup> <FormButton type=\"submit\" onClick={handleSubmit}>Save Trade</FormButton> <FormButton type=\"button\" onClick={handleBack}>Cancel</FormButton> </ButtonGroup> </TradeContent> </CreateTradeContainer> ); } export default CreateTrade;",
  "src/components/DailyRoutine.jsx": "import React from 'react'; import { Link } from 'react-router-dom'; import styled from 'styled-components'; const DailyRoutineContainer = styled.div` max-width: 1820px; margin: 20px auto; height: 100vh; /* Фиксируем высоту на весь экран */ background-color: #1a1a1a; padding: 20px; overflow: hidden; /* Убираем весь скролл */ display: flex; flex-direction: column; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; text-decoration: none; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: \"Back\"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const RoutineContent = styled.div` flex: 1; /* Занимает оставшееся пространство */ display: flex; justify-content: center; align-items: center; overflow: hidden; /* Убираем скролл внутри контента */ `; const TabsContainer = styled.div` display: flex; flex-direction: column; gap: 40px; /* Уменьшаем расстояние до разумного значения */ justify-content: center; align-items: center; width: 100%; `; const TabButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); color: #fff; border: none; padding: 30px; border-radius: 15px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; font-size: 1.8em; width: 720px; max-width: 90%; /* Ограничиваем ширину для маленьких экранов */ height: 180px; /* Уменьшаем высоту с 225px до 180px, чтобы уместить обе кнопки */ display: flex; align-items: center; justify-content: center; text-decoration: none; &:hover { transform: scale(1.05); opacity: 0.9; } &:active { transform: scale(0.95); } `; function DailyRoutine() { return ( <DailyRoutineContainer> <Header> <BackButton to=\"/\" title=\"Back to Home\" aria-label=\"Back to Home\" /> <Title>Daily Routine</Title> </Header> <RoutineContent> <TabsContainer> <TabButton to=\"/daily-routine/pre-session\">Pre-Session Journal</TabButton> <TabButton to=\"/daily-routine/post-session\">Post-Session Journal</TabButton> </TabsContainer> </RoutineContent> </DailyRoutineContainer> ); } export default DailyRoutine;",
  "src/components/GalleryItem.jsx": "import React from 'react'; import { Link } from 'react-router-dom'; import styled from 'styled-components'; const GalleryItemStyled = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); border-radius: 20px; /* Збільшено заокруглення для більших кнопок */ height: 250px; /* Збільшено висоту для 1920x1080 */ width: 400px; /* Збільшено ширину для 1920x1080, щоб займати більше простору */ display: flex; flex-direction: column; justify-content: center; /* Центрування по висоті */ align-items: center; /* Центрування по ширині */ text-decoration: none; color: #fff; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); /* Збільшено тінь для більших кнопок */ &:hover { transform: scale(1.05); opacity: 0.9; } &:active { transform: scale(0.95); } `; const ItemTitle = styled.h3` margin: 0; font-size: 2em; /* Збільшено розмір тексту для більших кнопок */ `; const ItemDescription = styled.p` margin: 15px 0 0; /* Збільшено відступ для більших кнопок */ font-size: 1.1em; /* Збільшено розмір опису */ color: #e0e0e0; `; function GalleryItem({ title, path, description }) { return ( <GalleryItemStyled to={path}> <ItemTitle>{title}</ItemTitle> <ItemDescription>{description}</ItemDescription> </GalleryItemStyled> ); } export default GalleryItem;",
  "src/components/Home.jsx": "import React from 'react'; import GalleryItem from './GalleryItem.jsx'; import styled from 'styled-components'; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px; border-radius: 0 0 10px 10px; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; `; const Greeting = styled.h1` margin: 0; font-size: 2.5em; color: #fff; `; const WorkPhrase = styled.p` color: #ff8c00; margin-top: 10px; font-size: 1.2em; `; const Gallery = styled.div` display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 30px; margin-top: 168px; padding: 20px; width: 100%; overflow-x: hidden; `; function Home() { const galleryItems = [ { title: 'Trading Journal', path: '/trade-journal', description: 'Analyze your future trades in one place using our advanced tools and indicators.' }, { title: 'Daily Routine', path: '/daily-routine', description: 'Add your daily thoughts and plans.' }, { title: 'Performance Analysis', path: '/performance-analysis', description: 'Explore and improve your skills.' }, { title: 'Statistics', path: '/statistics', description: 'All information about your trading.' }, { title: 'Risk Management', path: '/risk-management', description: 'Save your deposit.' }, { title: 'Reporting System', path: '/reporting-system', description: 'Get detailed reports.' }, { title: 'Learning Section', path: '/learning-section', description: 'Learn new skills.' }, { title: 'Settings', path: '/settings', description: 'Make using app comfortable.' }, ]; const getGreeting = () => { const hour = new Date().getHours(); if (hour >= 4 && hour < 11) return 'Good Morning!'; if (hour >= 11 && hour < 17) return 'Good Afternoon!'; return 'Good Evening!'; }; return ( <> <Header> <Greeting>{getGreeting()}</Greeting> <WorkPhrase>Let's get to work!</WorkPhrase> </Header> <Gallery> {galleryItems.map((item) => ( <GalleryItem key={item.path} title={item.title} path={item.path} description={item.description} /> ))} </Gallery> </> ); } export default Home;",
  "src/components/TradeTableComponent.jsx": "import React from 'react'; import { useTable } from 'react-table'; import styled from 'styled-components'; import { Link } from 'react-router-dom'; const TradeTable = styled.table` width: 100%; border-collapse: collapse; background-color: #2e2e2e; border: 2px solid #5e2ca5; `; const TableHeader = styled.th` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: 1px solid #5e2ca5; padding: 12px; text-align: left; color: #fff; font-weight: bold; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); `; const TableCell = styled.td` border: 1px solid #5e2ca5; padding: 10px; text-align: left; color: #fff; background-color: #2e2e2e; `; const TableRow = styled.tr` &:nth-child(even) { background-color: #2e2e2e; } &:nth-child(odd) { background-color: #3e3e3e; } `; function TradeTableComponent({ columns, data, onRowClick }) { const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } = useTable({ columns, data }); return ( <TradeTable {...getTableProps()}> <thead> {headerGroups.map((headerGroup) => ( <tr {...headerGroup.getHeaderGroupProps()}> {headerGroup.headers.map((column) => ( <TableHeader {...column.getHeaderProps()} style={{ width: `${column.width}px` }}> {column.render('Header')} </TableHeader> ))} </tr> ))} </thead> <tbody {...getTableBodyProps()}> {rows.length === 0 ? ( <TableRow> <TableCell colSpan={columns.length} style={{ textAlign: 'center' }}> No trades yet </TableCell> </TableRow> ) : ( rows.map((row) => { prepareRow(row); return ( <TableRow className=\"table-row\" {...row.getRowProps()}> {row.cells.map((cell) => ( <TableCell {...cell.getCellProps()} style={{ width: `${cell.column.width}px` }}> {cell.column.Header === 'No.' ? ( <Link to={`/trade/${row.original.id}`} style={{ color: '#fff', textDecoration: 'none' }}> {cell.render('Cell')} </Link> ) : ( cell.render('Cell') )} </TableCell> ))} </TableRow> ); }) )} </tbody> </TradeTable> ); } export default TradeTableComponent;",
  "src/components/ActionButtons.jsx": "import React from 'react'; import styled from 'styled-components'; import EditIcon from '../assets/icons/edit-icon.svg'; import DeleteIcon from '../assets/icons/delete-icon.svg'; const ButtonsContainer = styled.div` display: flex; gap: 10px; opacity: 0; transition: opacity 0.2s ease; .table-row:hover & { opacity: 1; } `; const IconButton = styled.button` /* Виправив помилку, додавши визначення IconButton */ background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; cursor: pointer; width: 24px; height: 24px; border-radius: 4px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); &:hover { filter: brightness(1.5); } img { width: 16px; height: 16px; } `; function ActionButtons({ tradeId, onEdit, onDelete }) { return ( <ButtonsContainer> <IconButton onClick={() => onEdit(tradeId)}> <img src={EditIcon} alt=\"Edit\" /> </IconButton> <IconButton onClick={() => onDelete(tradeId)}> <img src={DeleteIcon} alt=\"Delete\" /> </IconButton> </ButtonsContainer> ); } export default ActionButtons;",
  "src/components/Trash.jsx": "import React, { useState, useEffect } from 'react'; import { useTable } from 'react-table'; import { useNavigate } from 'react-router-dom'; import styled from 'styled-components'; const TrashContainer = styled.div` max-width: 1820px; margin: 20px auto; min-height: 100vh; background-color: #1a1a1a; padding: 20px; color: #fff; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled.button` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: 'Back'; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const TrashContent = styled.div` margin-top: 168px; padding-top: 20px; `; const TrashTable = styled.table` width: 100%; border-collapse: collapse; background-color: #2e2e2e; border: 2px solid #5e2ca5; `; const TableHeader = styled.th` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: 1px solid #5e2ca5; padding: 12px; text-align: left; color: #fff; font-weight: bold; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); `; const TableCell = styled.td` border: 1px solid #5e2ca5; padding: 10px; text-align: left; color: #fff; background-color: #2e2e2e; `; const TableRow = styled.tr` &:nth-child(even) { background-color: #2e2e2e; } &:nth-child(odd) { background-color: #3e3e3e; } `; const ActionButtons = styled.div` display: flex; gap: 10px; margin-top: 10px; `; const ActionButton = styled.button` background: conic-gradient(from 45deg, #7425C9, #B886EE); color: #fff; border: none; padding: 8px 16px; border-radius: 15px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; &:hover { transform: scale(1.05); opacity: 0.9; } &:active { transform: scale(0.95); } `; function Trash() { const [deletedTrades, setDeletedTrades] = useState([]); const navigate = useNavigate(); useEffect(() => { const loadDeletedTrades = async () => { try { const loadedTrades = await window.electronAPI.getDeletedTrades(); setDeletedTrades(loadedTrades || []); } catch (error) { console.error('Error loading deleted trades:', error); setDeletedTrades([]); } }; loadDeletedTrades(); }, []); const columns = React.useMemo( () => [ { Header: 'No.', accessor: (row, i) => i + 1, width: 20 }, { Header: 'Date', accessor: 'date', width: 129 }, { Header: 'Pair', accessor: 'pair', width: 129 }, { Header: 'Session', accessor: 'session', width: 110 }, { Header: 'Direction', accessor: 'direction', width: 110 }, { Header: 'Result', accessor: 'result', width: 110 }, { Header: 'Category', accessor: 'tradeClass', width: 90 }, { Header: 'Profit in %', accessor: 'profitLoss', Cell: ({ value }) => `${value}%`, width: 90 }, { Header: 'Profit in $', accessor: 'gainedPoints', Cell: ({ value }) => `$${value}`, width: 90 }, ], [] ); const { getTableProps, getTableBodyProps, headerGroups, rows, prepareRow } = useTable({ columns, data: deletedTrades }); const handleBack = () => { navigate('/settings'); // Повернення до Settings }; const handleRestore = async (trade) => { try { await window.electronAPI.restoreTrade(trade); setDeletedTrades(deletedTrades.filter((t) => t.id !== trade.id)); } catch (error) { console.error('Error restoring trade:', error); } }; const handleDeletePermanently = async (tradeId) => { try { await window.electronAPI.deletePermanently(tradeId); setDeletedTrades(deletedTrades.filter((t) => t.id !== tradeId)); } catch (error) { console.error('Error deleting trade permanently:', error); } }; return ( <TrashContainer> <Header> <BackButton onClick={handleBack} /> <Title>Trash</Title> </Header> <TrashContent> <TrashTable {...getTableProps()}> <thead> {headerGroups.map((headerGroup) => ( <tr {...headerGroup.getHeaderGroupProps()}> {headerGroup.headers.map((column) => ( <TableHeader {...column.getHeaderProps()} style={{ width: `${column.width}px` }}> {column.render('Header')} </TableHeader> ))} </tr> ))} </thead> <tbody {...getTableBodyProps()}> {rows.length === 0 ? ( <TableRow> <TableCell colSpan={columns.length} style={{ textAlign: 'center' }}> No deleted trades yet </TableCell> </TableRow> ) : ( rows.map((row) => { prepareRow(row); return ( <TableRow {...row.getRowProps()}> {row.cells.map((cell) => ( <TableCell {...cell.getCellProps()} style={{ width: `${cell.column.width}px` }}> {cell.render('Cell')} </TableCell> ))} </TableRow> ); }) )} </tbody> </TrashTable> {rows.length > 0 && ( <ActionButtons> {rows.map((row) => ( <div key={row.original.id} style={{ marginTop: '10px' }}> <ActionButton onClick={() => handleRestore(row.original)}>Restore</ActionButton> <ActionButton onClick={() => handleDeletePermanently(row.original.id)}>Delete Permanently</ActionButton> </div> ))} </ActionButtons> )} </TrashContent> </TrashContainer> ); } export default Trash;",
  "src/components/EmotionsControl.jsx": "import React from 'react'; import { Link } from 'react-router-dom'; import styled from 'styled-components'; const LearningSectionContainer = styled.div` max-width: 1820px; margin: 20px auto; min-height: 100vh; background-color: #1a1a1a; padding: 20px; overflow-x: hidden; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; text-decoration: none; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: \"Back\"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const LearningContent = styled.div` margin-top: 148px; padding-top: 20px; overflow-x: hidden; `; function EmotionsControl() { return ( <LearningSectionContainer> <Header> <BackButton to=\"/learning-section\" title=\"Back to Learning Section\" aria-label=\"Back to Learning Section\" /> <Title>Emotions & Control</Title> </Header> <LearningContent> <p>This section will contain emotions and control tracking content.</p> </LearningContent> </LearningSectionContainer> ); } export default EmotionsControl;",
  "src/components/Notes.jsx": "import React from 'react'; import { Link } from 'react-router-dom'; import styled from 'styled-components'; const LearningSectionContainer = styled.div` max-width: 1820px; margin: 20px auto; min-height: 100vh; background-color: #1a1a1a; padding: 20px; overflow-x: hidden; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; text-decoration: none; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: \"Back\"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const LearningContent = styled.div` margin-top: 148px; padding-top: 20px; overflow-x: hidden; `; function Notes() { return ( <LearningSectionContainer> <Header> <BackButton to=\"/learning-section\" title=\"Back to Learning Section\" aria-label=\"Back to Learning Section\" /> <Title>Notes</Title> </Header> <LearningContent> <p>This section will contain general notes content.</p> </LearningContent> </LearningSectionContainer> ); } export default Notes;",
  "src/components/LearningSection.jsx": "import React from 'react'; import { Link } from 'react-router-dom'; import styled from 'styled-components'; const LearningSectionContainer = styled.div` max-width: 1820px; margin: 20px auto; min-height: 100vh; background-color: #1a1a1a; padding: 20px; overflow-x: hidden; `; const Header = styled.header` background: conic-gradient(from 45deg, #7425C9, #B886EE); padding: 20px 0; border-radius: 10px 10px 0 0; color: #fff; position: fixed; top: 0; left: 0; right: 0; z-index: 1000; height: 128px; min-height: 6.67vh; max-height: 128px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); display: flex; align-items: center; `; const BackButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); border: none; padding: 0; width: 200px; height: 100%; border-radius: 0; cursor: pointer; position: absolute; left: 0; top: 0; opacity: 0; transition: all 0.3s ease; text-decoration: none; &:hover { opacity: 1; transform: scale(1.1); } &:active { transform: scale(0.98); } &:before { content: \"Back\"; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.2em; color: rgba(255, 255, 255, 0); transition: color 0.3s ease; } &:hover:before { color: #fff; } `; const Title = styled.h1` margin: 0 auto; font-size: 2.5em; color: #fff; text-align: center; z-index: 1; `; const LearningContent = styled.div` margin-top: 120px; padding-top: 20px; overflow-x: hidden; `; const TabsContainer = styled.div` margin-top: 0; padding: 20px 0; display: grid; grid-template-columns: repeat(2, 1fr); gap: 40px; justify-content: center; justify-items: center; `; const TabButton = styled(Link)` background: conic-gradient(from 45deg, #7425C9, #B886EE); color: #fff; border: none; padding: 20px; border-radius: 10px; cursor: pointer; transition: transform 0.2s ease, opacity 0.2s ease; font-size: 1.2em; width: 80%; height: 150px; display: flex; align-items: center; justify-content: center; text-decoration: none; &:hover { transform: scale(1.05); opacity: 0.9; } &:active { transform: scale(0.95); } `; function LearningSection() { return ( <LearningSectionContainer> <Header> <BackButton to=\"/\" title=\"Back to Home\" aria-label=\"Back to Home\" /> <Title>Learning Section</Title> </Header> <LearningContent> <TabsContainer> <TabButton to=\"/learning-section/emotions\">Emotions & Control</TabButton> <TabButton to=\"/learning-section/notes\">Notes</TabButton> </TabsContainer> </LearningContent> </LearningSectionContainer> ); } export default LearningSection;",
  "src/index.jsx": "import React from 'react'; import { createRoot } from 'react-dom/client'; import { HashRouter } from 'react-router-dom'; import App from './App.jsx'; import 'styled-components'; const root = createRoot(document.getElementById('root')); root.render( <HashRouter> <App /> </HashRouter> );",
  "index.html": "<!DOCTYPE html> <html> <head> <meta charset=\"UTF-8\" /> <title>Trader Workspace</title> <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;\" /> </head> <body> <div id=\"root\"></div> <script src=\"./dist/bundle.js\"></script> </body> </html>",
  "main.js": "const { app, BrowserWindow, ipcMain } = require('electron'); const path = require('path'); const sqlite3 = require('sqlite3').verbose(); const fs = require('fs').promises; let db = null; let vaultPath = null; async function initializeDatabase() { if (vaultPath && db) return; vaultPath = path.join(app.getPath('documents'), 'TraderWorkspaceVault'); const dbPath = path.join(vaultPath, 'trades.db'); try { await fs.mkdir(vaultPath, { recursive: true }); db = new sqlite3.Database(dbPath, (err) => { if (err) throw new Error(`Database connection failed: ${err.message}`); console.log('SQLite database initialized at:', dbPath); }); // Таблиця trades db.run(` CREATE TABLE IF NOT EXISTS trades ( id TEXT PRIMARY KEY, date TEXT, account TEXT, pair TEXT, direction TEXT, positionType TEXT, risk TEXT, result TEXT, rr TEXT, profitLoss TEXT, gainedPoints TEXT, followingPlan INTEGER, bestTrade INTEGER, session TEXT, pointA TEXT, trigger TEXT, volumeConfirmation TEXT, entryModel TEXT, entryTF TEXT, fta TEXT, slPosition TEXT, score TEXT, category TEXT, topDownAnalysis TEXT, execution TEXT, management TEXT, conclusion TEXT ) `, (err) => { if (err) throw new Error(`Table trades creation failed: ${err.message}`); }); // Таблиця notes db.run(` CREATE TABLE IF NOT EXISTS notes ( id INTEGER PRIMARY KEY AUTOINCREMENT, tradeId TEXT, title TEXT, text TEXT, FOREIGN KEY (tradeId) REFERENCES trades(id) ) `, (err) => { if (err) throw new Error(`Table notes creation failed: ${err.message}`); }); // Таблиця daily_routines db.run(` CREATE TABLE IF NOT EXISTS daily_routines ( date TEXT PRIMARY KEY, preSession TEXT, postSession TEXT, emotions TEXT, notes TEXT ) `, (err) => { if (err) throw new Error(`Table daily_routines creation failed: ${err.message}`); }); } catch (error) { console.error('Error initializing database:', error); throw new Error('Database initialization failed'); } } function createWindow() { const win = new BrowserWindow({ width: 1920, height: 1080, webPreferences: { nodeIntegration: false, contextIsolation: true, preload: path.join(__dirname, 'preload.js'), }, }); win.loadFile('index.html'); initializeDatabase().catch(console.error); } app.whenReady().then(createWindow); app.on('window-all-closed', () => { if (db) db.close((err) => { if (err) console.error('Error closing database:', err); console.log('Database closed'); }); if (process.platform !== 'darwin') app.quit(); }); app.on('activate', () => { if (BrowserWindow.getAllWindows().length === 0) createWindow(); }); const ensureDatabaseInitialized = async () => { if (!db) { await initializeDatabase(); } if (!db) throw new Error('Database not initialized'); }; ipcMain.handle('save-trade', async (event, trade) => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.run( `INSERT OR REPLACE INTO trades (id, date, account, pair, direction, positionType, risk, result, rr, profitLoss, gainedPoints, followingPlan, bestTrade, session, pointA, trigger, volumeConfirmation, entryModel, entryTF, fta, slPosition, score, category, topDownAnalysis, execution, management, conclusion) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`, [ trade.id, trade.date || '', trade.account || '', trade.pair || '', trade.direction || '', trade.positionType || '', trade.risk || '', trade.result || '', trade.rr || '', trade.profitLoss || '', trade.gainedPoints || '', trade.followingPlan ? 1 : 0, trade.bestTrade ? 1 : 0, trade.session || '', trade.pointA || '', trade.trigger || '', trade.volumeConfirmation || '', trade.entryModel || '', trade.entryTF || '', trade.fta || '', trade.slPosition || '', trade.score || '', trade.category || '', JSON.stringify(trade.topDownAnalysis) || '[]', JSON.stringify(trade.execution) || '{}', JSON.stringify(trade.management) || '{}', JSON.stringify(trade.conclusion) || '{}', ], async (err) => { if (err) { console.error('Error saving trade:', err); reject(err); return; } if (trade.notes && trade.notes.length > 0) { for (const note of trade.notes) { await new Promise((noteResolve, noteReject) => { db.run( 'INSERT INTO notes (tradeId, title, text) VALUES (?, ?, ?)', [trade.id, note.title, note.text], (noteErr) => { if (noteErr) noteReject(noteErr); else noteResolve(); } ); }); } } resolve(true); } ); }); }); ipcMain.handle('get-trades', async () => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.all('SELECT * FROM trades', (err, tradeRows) => { if (err) { console.error('Error fetching trades:', err); reject(err); return; } const trades = tradeRows.map(row => ({ ...row, topDownAnalysis: JSON.parse(row.topDownAnalysis || '[]'), execution: JSON.parse(row.execution || '{}'), management: JSON.parse(row.management || '{}'), conclusion: JSON.parse(row.conclusion || '{}'), notes: [], })); const tradeIds = trades.map(trade => trade.id); if (tradeIds.length === 0) { resolve(trades); return; } db.all( 'SELECT * FROM notes WHERE tradeId IN (' + tradeIds.map(() => '?').join(',') + ')', tradeIds, (err, noteRows) => { if (err) { console.error('Error fetching notes:', err); reject(err); return; } trades.forEach(trade => { trade.notes = noteRows .filter(note => note.tradeId === trade.id) .map(note => ({ title: note.title, text: note.text })); }); resolve(trades || []); } ); }); }); }); ipcMain.handle('update-trade', async (event, tradeId, updatedTrade) => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.run( `UPDATE trades SET date = ?, account = ?, pair = ?, direction = ?, positionType = ?, risk = ?, result = ?, rr = ?, profitLoss = ?, gainedPoints = ?, followingPlan = ?, bestTrade = ?, session = ?, pointA = ?, trigger = ?, volumeConfirmation = ?, entryModel = ?, entryTF = ?, fta = ?, slPosition = ?, score = ?, category = ?, topDownAnalysis = ?, execution = ?, management = ?, conclusion = ? WHERE id = ?`, [ updatedTrade.date || '', updatedTrade.account || '', updatedTrade.pair || '', updatedTrade.direction || '', updatedTrade.positionType || '', updatedTrade.risk || '', updatedTrade.result || '', updatedTrade.rr || '', updatedTrade.profitLoss || '', updatedTrade.gainedPoints || '', updatedTrade.followingPlan ? 1 : 0, updatedTrade.bestTrade ? 1 : 0, updatedTrade.session || '', updatedTrade.pointA || '', updatedTrade.trigger || '', updatedTrade.volumeConfirmation || '', updatedTrade.entryModel || '', updatedTrade.entryTF || '', updatedTrade.fta || '', updatedTrade.slPosition || '', updatedTrade.score || '', updatedTrade.category || '', JSON.stringify(updatedTrade.topDownAnalysis) || '[]', JSON.stringify(updatedTrade.execution) || '{}', JSON.stringify(updatedTrade.management) || '{}', JSON.stringify(updatedTrade.conclusion) || '{}', tradeId, ], async (err) => { if (err) { console.error('Error updating trade:', err); reject(err); return; } await new Promise((delResolve, delReject) => { db.run('DELETE FROM notes WHERE tradeId = ?', [tradeId], (delErr) => { if (delErr) delReject(delErr); else delResolve(); }); }); if (updatedTrade.notes && updatedTrade.notes.length > 0) { for (const note of updatedTrade.notes) { await new Promise((noteResolve, noteReject) => { db.run( 'INSERT INTO notes (tradeId, title, text) VALUES (?, ?, ?)', [tradeId, note.title, note.text], (noteErr) => { if (noteErr) noteReject(noteErr); else noteResolve(); } ); }); } } resolve(true); } ); }); }); ipcMain.handle('delete-trade', async (event, tradeId) => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.run('DELETE FROM trades WHERE id = ?', [tradeId], (err) => { if (err) { console.error('Error deleting trade:', err); reject(err); return; } db.run('DELETE FROM notes WHERE tradeId = ?', [tradeId], (noteErr) => { if (noteErr) reject(noteErr); else resolve(true); }); }); }); }); ipcMain.handle('save-file', async (event, file) => { await ensureDatabaseInitialized(); const screenshotsPath = path.join(vaultPath, 'screenshots'); await fs.mkdir(screenshotsPath, { recursive: true }); const filePath = path.join(screenshotsPath, `${Date.now()}-${file.name}`); await fs.writeFile(filePath, Buffer.from(await file.arrayBuffer())); return filePath; }); ipcMain.handle('save-blob-as-file', async (event, buffer) => { await ensureDatabaseInitialized(); const screenshotsPath = path.join(vaultPath, 'screenshots'); await fs.mkdir(screenshotsPath, { recursive: true }); const filePath = path.join(screenshotsPath, `${Date.now()}.png`); await fs.writeFile(filePath, Buffer.from(buffer)); return filePath; }); ipcMain.handle('save-daily-routine', async (event, routine) => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.run( `INSERT OR REPLACE INTO daily_routines (date, preSession, postSession, emotions, notes) VALUES (?, ?, ?, ?, ?)`, [ routine.date, JSON.stringify(routine.preSession || ''), JSON.stringify(routine.postSession || ''), JSON.stringify(routine.emotions || ''), JSON.stringify(routine.notes || ''), ], (err) => { if (err) { console.error('Error saving daily routine:', err); reject(err); } else { resolve(true); } } ); }); }); ipcMain.handle('get-daily-routine', async (event, date) => { await ensureDatabaseInitialized(); return new Promise((resolve, reject) => { db.get('SELECT * FROM daily_routines WHERE date = ?', [date], (err, row) => { if (err) { console.error('Error fetching daily routine:', err); reject(err); } else if (row) { resolve({ date: row.date, preSession: JSON.parse(row.preSession || '[]'), postSession: JSON.parse(row.postSession || '[]'), emotions: JSON.parse(row.emotions || '[]'), notes: JSON.parse(row.notes || '[]'), }); } else { resolve({ date, preSession: [], postSession: [], emotions: [], notes: [], }); } }); }); });",
  "preload.js": "const { contextBridge, ipcRenderer } = require('electron'); contextBridge.exposeInMainWorld('electronAPI', { saveTrade: (trade) => ipcRenderer.invoke('save-trade', trade), getTrades: () => ipcRenderer.invoke('get-trades'), updateTrade: (tradeId, updatedTrade) => ipcRenderer.invoke('update-trade', tradeId, updatedTrade), deleteTrade: (tradeId) => ipcRenderer.invoke('delete-trade', tradeId), saveFile: (file) => ipcRenderer.invoke('save-file', file), saveBlobAsFile: (buffer) => ipcRenderer.invoke('save-blob-as-file', buffer), saveDailyRoutine: (routine) => ipcRenderer.invoke('save-daily-routine', routine), getDailyRoutine: (date) => ipcRenderer.invoke('get-daily-routine', date), });",
  "webpack.config.js": "const path = require('path'); module.exports = { entry: './src/index.jsx', output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', }, module: { rules: [ { test: /\\.(js|jsx)$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-react'], plugins: [ '@babel/plugin-transform-runtime', '@babel/plugin-proposal-class-properties', 'babel-plugin-styled-components', ], }, }, }, { test: /\\.svg$/, use: [ { loader: 'file-loader', options: { name: '[name].[ext]', outputPath: 'assets/', }, }, ], }, ], }, target: 'electron-renderer', };",
  "package.json": "{ \"name\": \"traderworkspace\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"dependencies\": { \"boolean\": \"^3.2.0\", \"buffer-crc32\": \"^0.2.13\", \"cacheable-lookup\": \"^5.0.4\", \"cacheable-request\": \"^7.0.4\", \"clone-response\": \"^1.0.3\", \"debug\": \"^4.4.0\", \"decompress-response\": \"^6.0.0\", \"defer-to-connect\": \"^2.0.1\", \"define-data-property\": \"^1.1.4\", \"define-properties\": \"^1.2.1\", \"detect-node\": \"^2.1.0\", \"end-of-stream\": \"^1.4.4\", \"env-paths\": \"^2.2.1\", \"es-define-property\": \"^1.0.1\", \"es-errors\": \"^1.3.0\", \"es6-error\": \"^4.1.1\", \"escape-string-regexp\": \"^4.0.0\", \"extract-zip\": \"^2.0.1\", \"fd-slicer\": \"^1.1.0\", \"fs-extra\": \"^8.1.0\", \"get-stream\": \"^5.2.0\", \"global-agent\": \"^3.0.0\", \"globalthis\": \"^1.0.4\", \"gopd\": \"^1.2.0\", \"got\": \"^11.8.6\", \"graceful-fs\": \"^4.2.11\", \"has-property-descriptors\": \"^1.0.2\", \"http-cache-semantics\": \"^4.1.1\", \"http2-wrapper\": \"^1.0.3\", \"json-buffer\": \"^3.0.1\", \"json-stringify-safe\": \"^5.0.1\", \"jsonfile\": \"^4.0.0\", \"keyv\": \"^4.5.4\", \"lowercase-keys\": \"^2.0.0\", \"matcher\": \"^3.0.0\", \"mimic-response\": \"^1.0.1\", \"ms\": \"^2.1.3\", \"normalize-url\": \"^6.1.0\", \"object-keys\": \"^1.1.1\", \"once\": \"^1.4.0\", \"p-cancelable\": \"^2.1.1\", \"pend\": \"^1.2.0\", \"progress\": \"^2.0.3\", \"pump\": \"^3.0.2\", \"quick-lru\": \"^5.1.1\", \"react\": \"^18.2.0\", \"react-dom\": \"^18.2.0\", \"react-router-dom\": \"^7.2.0\", \"react-table\": \"^7.8.0\", \"resolve-alpn\": \"^1.2.1\", \"responselike\": \"^2.0.1\", \"roarr\": \"^2.15.4\", \"semver\": \"^6.3.1\", \"semver-compare\": \"^1.0.0\", \"serialize-error\": \"^7.0.1\", \"sprintf-js\": \"^1.1.3\", \"sqlite3\": \"^5.1.7\", \"styled-components\": \"^6.1.15\", \"sumchecker\": \"^3.0.1\", \"type-fest\": \"^0.13.1\", \"undici-types\": \"^6.19.8\", \"universalify\": \"^0.1.2\", \"wrappy\": \"^1.0.2\", \"yauzl\": \"^2.10.0\" }, \"devDependencies\": { \"@babel/core\": \"^7.26.9\", \"@babel/plugin-proposal-class-properties\": \"^7.18.6\", \"@babel/plugin-transform-runtime\": \"^7.26.9\", \"@babel/preset-env\": \"^7.26.9\", \"@babel/preset-react\": \"^7.26.3\", \"babel-loader\": \"^9.2.1\", \"babel-plugin-styled-components\": \"^2.1.4\", \"css-loader\": \"^7.1.2\", \"electron\": \"^34.2.0\", \"electron-rebuild\": \"^3.2.9\", \"file-loader\": \"^6.2.0\", \"style-loader\": \"^4.0.0\", \"webpack\": \"^5.98.0\", \"webpack-cli\": \"^6.0.1\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\", \"start\": \"electron .\", \"build\": \"webpack --mode production\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"description\": \"\" }",
  "README.md": "# TraderWorkspace ## Опис проєкту **TraderWorkspace** — це десктопний додаток на основі Electron, розроблений для трейдерів, щоб допомогти їм вести журнал трейдів, відстежувати щоденні рутини, аналізувати продуктивність, управляти ризиками, створювати звіти і вчитися новим стратегіям. Додаток надає зручний інтерфейс із темним дизайном, подібним до Obsidian, із фіолетовими акцентами, і дозволяє локально зберігати дані у базі даних SQLite, забезпечуючи конфіденційність і швидкість, як у текстових файлах Markdown. ### Ідея програми TraderWorkspace призначений для трейдерів, які хочуть організувати свої торгові операції, аналізувати історичні дані і покращувати свої стратегії. Основна мета — створити всебічний інструмент для: - Журналу трейдів (Trade Journal) із можливістю додавання, редагування, видалення і фільтрації трейдів. - Щоденної рутини (Daily Routine) для планування і відстеження торгових звичок. - Аналізу продуктивності (Performance Analysis) для оцінки результатів торгів (загальна прибутковість, середній профіт/збиток тощо). - Статистики (Statistics) із фільтрами (за датою, активом, результатом), категоріями (прибутковість, ризики) і відображенням графіків/діаграм (наприклад, через Chart.js або D3.js). - Управління ризиками (Risk Management) для оцінки і мінімізації ризиків (аналіз позиційного розміру, волатильності). - Навчальної секції (Learning Section) для вивчення торгових стратегій із інтерактивними уроками і нотатками. - Системи звітів (Reporting System) для генерації звітів у форматах PDF або JSON для експорту даних. - Налаштувань (Settings) для конфігурації додатку (темна/світла тема, вибір папки для даних, синхронізація через Dropbox тощо). Додаток інспірований простотою і портативністю Obsidian, але адаптований для трейдерів із фокусом на локальному зберіганні даних і потужному аналізі. --- ## Поточний стан реалізації ### Реалізовано - **Trade Journal:** - Додавання, редагування, видалення і фільтрація трейдів (за тиждень, місяць, усі трейди). - Таблиця з інформацією про трейди (дата, актив, рахунок, пара, сесія, напрямок, результат, позиційний розмір, отримані пункти, клас трейду тощо). - Темний дизайн із фіолетовими акцентами (#5e2ca5) і анімацією кнопок, реалізований через `styled-components`. - Локальне зберігання трейдів у SQLite через бібліотеку `sqlite3` у файлі `trades.db` у папці `Documents/TraderWorkspaceVault`. - **Основний інтерфейс (Home):** - Головне меню з галереєю кнопок для переходу до розділів (Trade Journal, Daily Routine, Performance Analysis, Statistics, Risk Management, Learning Section, Reporting System, Settings). - Привітання (\"Good Morning!\", \"Good Afternoon!\", \"Good Evening!\") із фразою \"Let's get to work!\". - **Технологічний стек:** - **Electron 34.2.0** для створення кросплатформового десктопного додатку. - **React 18.2.0** для побудови UI-компонентів. - **SQLite3** для локального зберігання даних у файлі `trades.db`. - **styled-components 6.1.15** для CSS-in-JS стилізації з темним фоном (#1a1a1a) і фіолетовими акцентами (#5e2ca5). - **react-router-dom 7.2.0** для навігації між сторінками. - **react-table 7.8.0** для створення таблиці трейдів із пагінацією. - **Webpack 5.98.0** для компіляції React-коду в `dist/bundle.js`. - **Babel** (з `babel-loader`, `@babel/preset-react`, `@babel/plugin-transform-runtime`, `@babel/plugin-proposal-class-properties`, `babel-plugin-styled-components`) для підтримки JSX і сучасного JavaScript. - **Інфраструктура:** - Локальне збереження даних у файлі `trades.db`, подібно до текстових файлів у Obsidian. - Автоматичне створення і збереження даних без діалогових вікон, як у Vault Obsidian. ### Плани на майбутнє - **Короткострокові цілі (1-2 місяці):** - Реалізувати секцію \"Statistics\" із фільтрами (дата, актив, результат), категоріями (прибутковість, ризики), і графіками (Chart.js або D3.js). - Додати базову функціональність \"Daily Routine\" для планування і відстеження торгових звичок. - **Середньострокові цілі (3-6 місяців):** - Розробити \"Performance Analysis\" для аналізу продуктивності трейдера (загальна прибутковість, середній профіт/збиток, статистика за періодами). - Додати \"Risk Management\" із інструментами оцінки ризиків (аналіз позиційного розміру, волатильності, відсотка ризику). - **Довгострокові цілі (6+ місяців):** - Реалізувати \"Learning Section\" із інтерактивними уроками, нотатками і прикладами стратегій, збереженими у SQLite. - Створити \"Reporting System\" для генерації звітів у форматах PDF або JSON із можливістю експорту. - Додати підтримку тем (темна/світла) через `styled-components` і `ThemeProvider`, а також синхронізацію через Dropbox у \"Settings\". --- ## Вимоги до програмного забезпечення ### Для розробки - **Node.js 20.18.2** — використовується для запуску проєкту і менеджменту залежностей через npm. Рекомендується використовувати `nvm-windows` для Windows для легкого перемикання версій: - Завантажте `nvm-windows` з [github.com/coreybutler/nvm-windows](https://github.com/coreybutler/nvm-windows/releases). - Встановіть і виконайте: ```bash nvm install 20.18.2 nvm use 20.18.2 ## Примітки для чат-ботів або AI Цей проєкт є десктопним додатком для трейдерів на Electron з React, SQLite, і styled-components. Якщо ви чат-бот або AI (наприклад, Grok 3), ви можете: - Допомагати реалізувати нові функції, такі як \"Statistics\" (з Chart.js для графіків, фільтрами за датою/активом, категоріями). - Пропонувати код для додавання \"Daily Routine\", \"Performance Analysis\", або інших розділів. - Надавати поради з оптимізації, тестування (наприклад, із Jest), чи інтеграції нових бібліотек (наприклад, D3.js, pdfkit для звітів). - Допомагати з налаштуванням Webpack, Babel, або Electron для нових функцій. - Використовуйте цей контекст для розуміння структури, технологій, і цілей проєкту, щоб відповідати на запити, наприклад: - \"Як додати графіки у Statistics, використовуючи Chart.js, у моєму проєкті TraderWorkspace?\" - \"Як реалізувати темну/світлу тему через styled-components?\" - \"Як додати експорт даних у PDF для Reporting System?\" Будь ласка, враховуйте технологічний стек (Electron 34.2.0, React 18.2.0, SQLite3, styled-components 6.1.15, Webpack 5.98.0, Babel), темний дизайн (#1a1a1a фон, #5e2ca5 акценти), локальне зберігання у SQLite (`trades.db` у `Documents/TraderWorkspaceVault`), і структуру проєкту, описану вище. ``` ## Оновлення від 26 лютого 2025 року Сьогодні ми внесли низку покращень до проєкту \"Trader Workspace\", зосередившись на функціональності збереження трейдів, обробці скріншотів і виправленні помилок. Ось що було реалізовано: ### Основні зміни 1. **Виправлення помилки збереження трейдів у SQLite:** - Вирішено проблему `SQLITE_ERROR: 26 values for 27 columns`, синхронізувавши кількість значень у запиті `INSERT OR REPLACE INTO trades` із визначенням таблиці (27 колонок). - Додано коректну обробку всіх полів трейду, включаючи `topDownAnalysis`, `execution`, `management` і `conclusion`, які зберігаються як JSON. 2. **Окрема таблиця для Notes & Mistakes:** - Створено нову таблицю `notes` у SQLite для зберігання нотаток (`title` і `text`) із зовнішнім ключем `tradeId`, що пов’язує їх із трейдами. - Оновлено методи `save-trade`, `get-trades`, `update-trade` і `delete-trade`, щоб нотатки зберігалися та отримувалися з окремої таблиці. 3. **Покращення обробки скріншотів:** - Додано підтримку вставки зображень із буфера обміну через Clipboard API. Зображення конвертуються в `ArrayBuffer` і зберігаються у `TraderWorkspaceVault/screenshots/` як PNG-файли. - Реалізовано перегляд зображень на весь екран при кліку на них із модальним вікном і кнопкою закриття. - Прибрано відображення шляху до файлу в інтерфейсі; тепер показується лише зображення. - Зображення відображаються з правильними пропорціями (`width: 100%`, `height: auto`), зберігаючи ширину блоку. 4. **Інтерфейсні покращення:** - Поля `<ScreenshotInput>` і `<TextArea>` вирівняно по центру блоку за допомогою `flex` і `align-items: center`. - Додано відступ між полями \"RR\" і \"Profit (%)\" у формі трейду, зберігши `gap: 15px` у `<FormRow>`. 5. **Виправлення іконок:** - Шлях до іконок (`edit-icon.svg`, `delete-icon.svg`) змінено на `/assets/`, з рекомендацією розмістити їх у `public/assets/` для коректного завантаження в Electron. ### Виправлені помилки - **Помилка збереження трейдів:** Вирішено проблему з невідповідністю колонок і значень у SQLite. - **Проблема з \"Cancel\":** Перехід на `/trade-journal` із параметром `{ replace: true }` для уникнення зникнення кнопок \"Add new Trade\" і \"Filter\". ### Рекомендації для запуску - Видаліть стару базу даних (`C:\\Users\\<YourUser>\\Documents\\TraderWorkspaceVault\\trades.db`), щоб уникнути конфліктів зі старою схемою. - Розмістіть файли `edit-icon.svg` і `delete-icon.svg` у `public/assets/`. - Виконайте: ```bash npm run build npm start",
  ".gitignore": "node_modules/ *.log"
}